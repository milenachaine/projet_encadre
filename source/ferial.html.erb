---
site:
  title: Projet BAO
  categorie: Ferial Yahiaoui
  description: Projet de traitement automatique des langues, utilisant Perl et XSLT

author:
  all: Milena Chaîne, Margaux Duhayon, Ferial Yahiaoui
  milena: Milena Chaîne
  margaux: Margaux Duhayon
  ferial: Ferial Yahiaoui
  school: Inalco

master:
  site: "http://www.tal.univ-paris3.fr/plurital/"
  

layout: ferial

---

<% content_for :logo do %>
<%= image_tag "box2.jpg" %>
<% end %>


<p>Bienvenue sur ma page.</p>
<p>J'ai pour ma part travaillé sur les rubriques suivantes:<br/>
<br/> - La rubrique 3476 qui est la rubrique <em>Cinéma</em>.
<br/> - La rubrique 3232 qui est la rubrique <em>Idées</em>.
<br/> - la rubrique 3260  qui est la rubrique <em>Livres</em>.</p>

<p>Le choix des rubriques s'est fait en fonction des thèmes pouvant être liés les uns aux autres. Etant donné qu'il est question de l'actualité de l'année 2017 concernant le cinéma et les livres, mais aussi au sujet des interviews et des tribunes (rubrique Idées) ayant été rapportées par le journal Le Monde tout au long de l'année. Pour la rubrique Idées, par exemple, nous pensons que que le contenu sera tourné plus vers un style argumentatif que descriptif). De ce fait, l'hypothèse de départ est que nos résultats de patrons vont probablement refléter les évènements marquants de l'année 2017. Pour plus de pertinence dans le choix des motifs à la dernière étape du projet, un parallèle sera fait entre les résultats obtenus et nos recherches concernant tout ce qui a pu marqué l'actualité au courant de cette année autour de ces thèmes.  </p>

<p>Cette page contient les différentes Boîtes à Outils, leurs explications, les résultats obtenus, ainsi que les analyses qui en découlent.</p>
<p>Tous les scripts sont visibles sur la page elle-même et téléchargeables. Pour naviguer entre les différentes boîtes à outils, vous pouvez utiliser la barre d'onglets ci-dessous.</p>

<p>Bonne visite !</p>



<%= partial "partials/h3", :locals => { :raccourci => "bao1_2", :titre => "Boîtes à outils 1 et 2 : Parcours, filtrage, création et étiquetage des fichiers créés"} %>
<%= partial "partials/onglets_bao_ferial" %>



	
	<%= image_tag 'schema/bao_schema_1_2.png' %>

	<p>La deuxième BAO utilise les résultats de la première. En effet, la BAO1 s’occupe d’extraire le texte de chaque rubrique en récupérant le titre et la description de celles-ci, sous deux formats : un texte brut + un fichier XML. Tout cela en parcourant l’arborescence du fils RSS jusqu’au traitement de toutes les rubriques. Ensuite, la BAO2 récupère les fichiers XML pour les étiqueter morphosyntaxiquement grâce à l’annotateur « TreeTagger ».
<br/>
Que faire de nos fichiers au format TXT?<br/>
Après les avoir converti en ISO 8859-15, on les passe à l’annotateur « Cordial » qui les étiquettera morphosyntaxiquement.<br/>
Ce sont ces fichiers étiquetés par deux annotateur différents qui seront utilisés par la BAO3.<br/>
Ci-dessous, le programme en question:

</p> 


<label>

<%= partial "partials/code", :locals => { :code_file => "assets/ferial/BAO2_extrac_etiq_utf.pl"} %>
 <% code("perl") do %>

#!/usr/bin/perl

<<DOC;
usage : perl BAO2_extrac_etiq.pl Library numéro de la rubrique 
Par exemple : perl BAO2_extrac_etiq.pl Library 3208
Le programme prend en entrée le nom du répertoire contenant les fichiers à traiter et le numéro de la rubrique à traiter
DOC

 #-----------------------------------------------------------
 
 # recupère le nom du répertoire racine 
 
 my $rep="$ARGV[0]"; 
 
 # recupère le nom de la rubrique
 
 my $rubrique = "$ARGV[1]";
 
 # initialise 
 
 my %dico=();

 $rep=~ s/[\/]$//; # assure que le nom du répertoire ne se termine pas par un "/" 

 $encodage = "utf-8"; 
 
 # initialisele  compteur de fichichiers à 1
 
 my $compteurfile=1; 
 
 # initialisation du compteur d items à 0
 
 my $compteuritem=0; 
 
 # initialise les fichiers d output 

 my $output1=$rubrique.".xml"; # initialisation du fichier d output XML 
 my $output2=$rubrique.".txt"; # initialisation du fichier d output TXT
 
 # ouvre les fichiers d output

 if(!open (FILEOUT, ">:encoding($encodage)", $output1)) { die "Pb à l'ouverture du fichier $output1" }; 
 if(!open (FILEOUT2, ">:encoding($encodage)", $output2)) { die "Pb à l'ouverture du fichier $output2" }; 
 
 # écris l entête du fichier d output XML

 print FILEOUT "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n";
 print FILEOUT "<PARCOURS>\n";
 print FILEOUT "<NOM>Ferial Yahiaoui</NOM>\n";
 print FILEOUT "<FILTRAGE>\n";


# lance la récursion...elle se terminera après examen de toute l arborescence

 #----------------------------------------
 &parcoursarborescencefichiers($rep);  
 #----------------------------------------

# réouvre le fichier d output XML et écris les balises fermantes

 if(!open (FILEOUT, ">>:encoding($encodage)", $output1)) { die "Pb à l'ouverture du fichier $output1" }; 

 print FILEOUT "\n</FILTRAGE>\n";
 print FILEOUT "</PARCOURS>\n";

# ferme le fichier XML

 close(FILEOUT); 
 

 exit;
 #----------------------------------------------
 
 # définis le sous-programme responsable de parcourir le répertoire
  
 sub parcoursarborescencefichiers {
	 
	 # récupère le répertoire
	 
     my $path = shift(@_); 
	 
	 # ouvre le répertorie reçu en argument, donc $path
	 
     opendir(DIR, $path) or die "can't open $path: $!\n"; 
	 
	 # lis le repertoire, readdir renvoit une liste, celle des fichiers à l intérieur de DIR, on les met dans un listes # ne traite pas./, courant../ précédent sinon, on se retrouve dans une boucle
	 
     my @files = readdir(DIR); 
     closedir(DIR);         
     foreach my $file (@files) { # la liste obtenue est relative au répertoire ouvert
     next if $file =~ /^\.\.?$/; # next: passe au prochain élément si l actuel ne correspond pas à celui chérché
     $file = $path."/".$file;  

	# vrai si l objet est un répertoire
	
     if (-d $file) { 
       print "<NOUVEAU REPERTOIRE> ==> ",$file,"\n";
		   
		   # récurse! 
		   
       &parcoursarborescencefichiers($file); 
       print "<FIN REPERTOIRE> ==> ",$file,"\n";
     }
	 
	 # vrai si l objet est un fichier
	 
     if (-f $file) { 
		 
		 # si le fichier en question correspond à ce pattern
		 
       if($file =~/$rubrique.+\.xml$/) 
       {
         print "<",$compteurfile++,"> ==> ",$file,"\n";  
		 
		 #  alors, ouvre le fichier de la rubrique pour 
        
         open (FIC, "<encoding($encodage)", $file);
		 
		 # intialise varaibale texte à une chaîne vide
		 
         my $texte="";
		 
		 # tant que la variable ligne prend comme valeur l ensemble du texte
		 
         while (my $ligne = <FIC>){
			 
		   # supprime les retours à la ligne
			 
           chomp $ligne;
		   
		   # nettoie la ligne du retour chariot
		   
           $ligne =~ s/\r//g;
		   
		   # concatène l ensemble du texte
		   
           $texte = $texte . $ligne;

       }
      
       close FIC;
	   
	   
       # nettoie le texte
	   
       $texte =~ s/>\s+</></g;
	   
	   # tant que le texte recherché correspond à ce match
      
       while($texte=~ 
       m/<item>.*?<title>([^<]*?)<\/title>.*?<description>([^<]*?)<\/description>/g)
       { 
        
		# stocke les titres dans la variable $titre 
         my $titre = $1;
		 
		 # stocke les descriptions dans la variable $description
		 
         my $description = $2;
		 
        
         ($titre, $description) = &nettoyage($titre, $description); # appel du sous-programme nettoyage
         if(!(exists $dico {$titre})) # ne prends pas en compte les titres redondants 
         { 
           $dico{$titre} = 1;
          
           print FILEOUT2 "$titre.\n$description\n\n";
          
          
           $compteurItem++;
		   
		   # initialisation des variables contenant les titres + descriptions étiquetés
          
           my ($titre_etiq, $description_etiq) = &etiquetage($titre, $description);
		   
		   # écris dans l'output XML le contenu étiqueté
		   
           print FILEOUT "<item number=\"$compteurItem\">\n<titre>$titre_etiq</titre>\n<description>$description_etiq</description>\n</item>\n";
        
         }
  
       }   

       }
      
      
    
     }
 }
 
 # définition du sous-programme nettoyage
 
 sub nettoyage {

   # @_ c'est une liste
   # my $var1 = $_[0];

   my $var1 = shift(@_);   # shift supprime le premier élément et le recupère dans une variable
   my $var2 = shift(@_);
   
   # $var1 et $var2 prennennet respectivement les valeurs des titres et descriptions 
   
   # nettoie les titres + descriptions des entités HTML

     $var1 =~s/&lt;.+?&gt;//g;
     $var2 =~s/&lt;.+?&gt;//g;
     $var1 =~s/&amp;/et/g;
     $var2 =~s/&amp;/et/g;
     $var1=~s/\?\.$/\?/;
  
   return $var1,$var2;

 }
 #----------------------------------------------
 
 # définition du sous-programme étiquetage
 
 sub etiquetage {

   my $var1 = shift(@_); # l'input est le titre et la description
   my $var2 = shift(@_);

   #-------------------titre
  
   open(OUT, ">:encoding(utf8)", "titre_tmp.txt"); 
   print OUT $var1;
  
   close OUT;

  # system permet de lancer une commande de notre système d exploitation, ici une commande bash
  # la première permettant de segmenter les titres en tokens et de les passer à l annotateur TreeTagger
  
   system("perl tokenise-utf8.pl titre_tmp.txt | ./tree-tagger/bin/tree-tagger -lemma -token -no-unknown ./tree-tagger/lib/french-utf8.par > titre_tmp_etiq.txt"); # resultat envoyé dans des fichiers temporaires permattant de stocker chaque titre traité
   
   # la seconde commande permet de trasnformer le résultat de l'étiquetage en fichier XML
   
   system("perl treetagger2xml-utf8.pl titre_tmp_etiq.txt utf8"); 
   
   # le mode slurp permet de lire, localement, le texte d une traite
   
   local $/=undef;
   
   open (FIC, "<:encoding(utf8)", "titre_tmp_etiq.txt.xml");
   my $titre_retour=<FIC>;
   $titre_retour=~s/<\?xml version="1\.0" encoding="utf-8" standalone="no"\?>\n//;
  
   #------------------------------------------description
  
   open(OUT, ">:encoding(utf8)", "description_tmp.txt"); 
   print OUT $var2;

  
   close OUT;
  
   system("perl tokenise-utf8.pl description_tmp.txt | ./tree-tagger/bin/tree-tagger -lemma -token -no-unknown ./tree-tagger/lib/french-utf8.par
    > description_tmp_etiq.txt"); # resultat envoyé dans des fichiers temporaires permattnt de stocker chaque description traitée
	
   system("perl treetagger2xml-utf8.pl description_tmp_etiq.txt utf8");
   $/=undef;
   open (FIC, "<:encoding(utf8)", "description_tmp_etiq.txt.xml");
   my $description_retour=<FIC>;
   $description_retour=~s/<\?xml version="1\.0" encoding="utf-8" standalone="no"\?>\n//;
  
   return $titre_retour, $description_retour;  
  

  
 }
  
  
  
 }
 
  <% end %>
</label>
 
 <p><div class="explication"><%= image_tag 'cog_transparent_32px.png', :class => "icon" %>Ce programme se compose de quatre blocs: dont 3 sous-programmes où certais sont imbriqués les unes dans les autres.<br/><br/>


bloc1: <br/>

	 Le lancement du du programme requiert deux arguments qui sont le nom du répertoire contenant l’ensemble du fils RSS ainsi que le numéro de la rubrique choisie dont le texte doit être extrait. Il va ensuite initialiser les différents fichiers de sortie, de parcourir l’arborescence, donc le répertoire du fils RSS et d’en extraire le contenu ciblé.<br/><br/>


bloc2:<br/>

	La fonction récursive parcoursarboresence est définie et prend, s’il correspond à un répertoire, le premier élément, en l’occurrence le répertoire « Library » contenant les fichiers des rubriques. 
Elle fait elle-même appel au sous-programme etiquetage pour initialiser les variables contenant les titres et descriptions « nettoyés » par un autre sous-programme, nettoyage. <br/><br/>

bloc3: <br/>

	La fonction nettoyage est définie par la suppression des balises HTML et par le remplacement des entités HTML par leurs correspondants textuels.<br/>

bloc4: <br/> 
	
	pour chaque token (mot) nous obtenons sa catégorie morphosyntaxique et son lemme. La fonction étiquetage est définie par l’appel des programmes Perl responsables de la segmentation du texte, de son annotation, ainsi que de sa transformation en fichier XML. Ce dernier sera formé de balises indiquant pour chaque token sa catégorie morpho-syntaxique et son lemme.<br/>

Il est à noter que seul le fichier d’output XML est étiqueté morphosyntaxiquement par TreeTagger dans ce programme. Le fichier d’output TXT sera, quant à lui, étiqueté séparément par Cordial.<br/>

Les deux, seront par la suite utilisés par la BAO3 pour en extraire, à partir de patrons morpho-syntaxiques prédéfinis, les éléments lexicalisés qui y sont associés.
</p></div>

  <p><div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %> Les résultats obtenus par l'étiquetage des fichiers XML, <b><a href="assets/ferial/rubriques_etiquetees_tagger.zip" download>sont téléchargeables ici</a></b> et ceux obtenus par l'étiquetage des fichiers TXT par Cordial<b><a href="assets/ferial/rebriques_etiquetees_cordial" download> sont téléchargeables ici</a></b> .</p></div>
<center><p>Les fichiers XML étiquetés par TreeTagger se présentent ainsi :</p></center>
<center><%= image_tag 'ferial/3232_tagger.png' %></center>
<center><p>Les fichier TXT étiquetés par Cordial se présentent ainsi :</p></center>
<center><%= image_tag 'ferial/3232_cordial.png' %></center>


 
 
 
 <%= partial "partials/h3", :locals => { :raccourci => "bao3", :titre => "Boîte à outils 3 : Extraction des patrons morphosyntaxiques"} %>
 <%= partial "partials/onglets_bao_ferial" %>
 

 
  	<%= image_tag 'schema/bao_schema_3.png' %>

  	<p>L’objectif de la BAO3 est d’extraire, selon des patrons morphosyntaxiques donnés, les éléments lexicalisés correspondants et ce, grâce à plusieurs solutions proposées, en fonction des fichiers annotés à exploiter (fichiers TXT et XML étiquetés).

 

  </p> 
  



 <h4><B>1) Solutions Perl permettant l'extraction de patrons morphosyntaxiques à partir des fichiers TXT étiquetés par "Cordial" </B></h4>
 
<div class="explication"><p>	Les données des fichiers taggés par Cordial se structurent en 3 colonnes:<br/><br/>
					<ul>
	
					<li>1. le token</li><br/>
					<li>2. son lemme</li><br/>
					<li>3. sa catégorie morphosyntaxique</li><br/><br/>
					
				</ul>

Par exemple: rentabilité	rentabilité	NCFS<br/>
 
<br/>Les deux programmes prennent plusieurs arguments: le fichier taggé et la liste des éléments constitutifs du patron (exprimé chacun par exemple sur la forme d'une regexp).<br/>

Les programmes doivent retrouner des éléments lexicalisés correpsondant aux patrons indiqués.
</p></div><br/><br/>




 
 <%= image_tag 'cog_transparent_32px.png', :class => "icon" %><B>1.1) Premier programme Perl</B>
 
 
 <div class="explication"><p> Cette solution permet de comparer des chaînes de caractères avec une suite de POS grâce à une expression régulière. L'inconvénient qu'elle présente c'est qu'il faut à chaque fois changer l'argument du fichier de patron recherché visé.

 </p></div><br/><br/>
 
 
 <label>
 
<%= partial "partials/code", :locals => { :code_file => "assets/ferial/BAO3_patrons_utf"} %> 
 <% code("perl") do %>
 
  #!/usr/bin/perl
  
 <<DOC;
 usage : perl BAO3_patrons.pl rubrique_utf.cnr patrons.txt 
 Par exemple : perl BAO3_patrons.pl 3208_utf.cnr patrons.txt
 Le programme prend en entree la sortie Cordial la rubrique etiquetee et des patrons morphosyntaxiques a extraire correspondant a l expression reguliere (exemple : NC.. PREP NC..)
 DOC


 #----------------------------------------
 use utf8;
 binmode STDOUT, ":utf8";
 my $chaine="";
 open (FIC, "<:encoding(utf8)", $ARGV[0]);

 while (my $ligne=<FIC>) { 

 	chomp $ligne; 
 	$ligne=~s/\r//g; 

 	#print $ligne;

 	if (($ligne=~/^(.+?)\t.+?\t(.+?)$/) and ($ligne !~/PCTFORTE/)) { 
	
 		my $f=$1;
 		
 		my $c=$2;
 		
		$f=~s/ /#/g; 
		

 

 	$chaine = $chaine . $c."_".$f." ";
 	#$chaine = $chaine . $c."_".$f." ";
 	#print $chaine;
 	
 	# print $chaine;
 	# $continu=<STDIN>; 
 

 	}
 	else {
 		#print $chaine;
 		#$continu=<STDIN>;
 		open(TERM,$ARGV[1]);
 		while (my $terme=<TERM>){ 
			
 			chomp($terme);
 			$terme=~s/([^ ]+)/$1_\[\^ \]+/g;
 			
 			
 			while ($chaine=~/$terme/g){
 			
 				my $correspondance=$&;
 				$correspondance=~s/[A-Z]+_//g;
 				$correspondance=~s/#/ /g;
 				print $correspondance, "\n";
 			}

 		}
 		close(TERM);
 		$chaine=""; 
 	}


 	} 

 close (FIC);
 
  <% end %>
   </label>


  <%= image_tag 'cog_transparent_32px.png', :class => "icon" %><B>1.2) Deuxième programme Perl (programme N-grammes)</B> 
  
  <div class="explication"><p>	Pour cette solution, j'ai opté pour celle proposée par Axel Court. En effet, des tables de hachage sont utilisées dans ce script qui consiste à chercher chaque patron devenant la clé d'un %hash. Au fur et à mesure qu'un patron est reconnu, il est ajouté à la liste des valeurs de cette clé. Chaque clé stockée dans une table de hachage est un objet unique, et sa valeur peut être représentée par une chaîne de caractères ($string) ou une liste (@liste). Dans notre cas, des @tableaux sont stockés dans une %hash. Cette option est avantageuse dans le sens où il est plus rapide de vérifier si les éléments constitutifs d'un patron de POS du fichier TXT étiqueté est une clé dans le tableau associatif, que de comparer deux strings. Elle présente cependant le désavantage d'exiger la précision dans la défintiion des patrons recherchés, car Cordial est précis dans son annotation contrairement à TreeTagger, qui lui, ne va pas dans le détail pour indiquer le genre et le nombre, par exemple, d'un adjectif ou d'un nom. 

  </p></div><br/><br/>
  
  
  
  <label>

  <%= partial "partials/code", :locals => { :code_file => "assets/ferial/extraction-hach-ngram-cordial_utf.pl"} %>
   
 <% code("perl") do %>

 #!/usr/bin/perl

#----------------------------------
# Ouverture des fichiers en lecture
#----------------------------------
open (FICTAG, $ARGV[0]) or die ("probleme sur ouverture de la sortie CORDIAL...");
open (FICPOS, $ARGV[1]) or die ("probleme sur ouverture du fichier des patrons...");
#----------------------------------------------------
# On stocke les patrons dans une table de hachage
#----------------------------------------------------
my %listedespatrons;
my @liste = ();
print "Lecture du fichier de POS\n";
while (my $lignepos = <FICPOS>) {
    chomp($lignepos);
    my @patron = split(/\#/, $lignepos);
  #------------------------------------------------------------------------------------------
  # @liste gardera en mémoire le nombre de POS dont est composé chaque patron syntaxique
    push(@liste, $#patron+1);
  #------------------------------------------------------------------------------------------
  $lignepos =~ s/#/ /g;
  #-----------------------------------------------------------------------------------------------------------------
  # Attention, on stocke des tableaux comme valeurs, donc initialiser ces valeurs à () et non "" !
  # Sinon le script stockera la totalité des suites reconnues (soit plus de 10 000) comme valeur de chaque clé !
    $listedespatrons{$lignepos} = ();
  #-----------------------------------------------------------------------------------------------------------------


}
#------------------------------------------------------------------------------------------------------------------------
# Suppression des doublons de @patron : on obtient des valeurs uniques qui serviront à générer des n-grammes de POS
my %listengramstemp  = map { $_, 1 } @liste;
my @listedesngrams = keys %listengramstemp;


#------------------------------------------------------------------------------------------------------------------------
close(FICPOS);
#---------------------------
# Initialisation des listes
#--------------------------
my @malignesegmentee = ();
my @listedetokens = ();
my @listedelemmes = ();
my @listedepos = ();
#-------------------------------------------
# Lecture du fichier de tags ligne par ligne
#-------------------------------------------
print "Lecture du fichier a analyser\n";
while (my $ligne = <FICTAG>) {
    #-------------------------------------------------------------------------------------
    # On ne s'occupe pas des lignes qui ne respectent pas la modèle mot tab mot tab mot
    #-------------------------------------------------------------------------------------
    
    if (($ligne=~/^[^\t]+\t[^\t]+\t[^\t]+$/) and ($ligne !~/PCTFORTE/)){
      
  #-------------------------------------------
  # Suppression du caractère de saut de ligne
  chomp($ligne);
  #-------------------------------------------
  # Remplissage des listes
  @malignesegmentee = split(/\t/, $ligne);
  push(@listedetokens, $malignesegmentee[0]);
  push(@listedelemmes, $malignesegmentee[1]);
  push(@listedepos, $malignesegmentee[2]);
  #-------------------------------------------
  
    }

}
close(FICTAG);
#--------------------------------------------------------------------------------------
# Génération de n-grammes de POS (en fonction du nombre de POS dans les patrons)
# et recherche si chaque n-gramme généré correspond à un patron de %listedespatrons
#--------------------------------------------------------------------------------------
print "Recherche des patrons syntaxiques\n";
foreach my $n (@listedesngrams) {
  $n = $n-1;
  my $j = 0;  
  until ($j+$n > $#listedepos) {
    my $ngram = join(" ", @listedepos[$j .. $j+$n]);
    
    #-----------------------------------------------------------------
    # Si la suite de POS est reconnue comme clé de %listedespatrons
    # on stocke les tokens correspondants en valeur du hash
    if (exists $listedespatrons{$ngram}) {
      my $motsreconnus = join(" ", @listedetokens[$j .. $j+$n]);
      push(@{$listedespatrons{$ngram}},$motsreconnus);
    #-----------------------------------------------------------------


      
    }
    $j++;
  }
}
#-------------------------------------------------
# Impression des résultats de l'extraction
#-------------------------------------------------
my $dump = "";
#-------------------------------------------------
# Parcours de la table de hachage
print "Ecriture des resultats\n";
while ( ($key, $value) = each(%listedespatrons) ) {
    $dump .= "------------------------\n";
    $dump .= "$key\n-------------------------\n";

  
  #--------------------------------------------------------------
  # Parcours du tableau contenant les suites de mots reconnues
  # qui correspondent au patron syntaxique (la clé)
    foreach my $term (@$value) {
    $dump .= $term;
    $dump .= "\n";

    
  #--------------------------------------------------------------
  }
  $dump .= "\n\n\n";
  
}
#-------------------------------------------------

open(OUT, ">:encoding(utf8)", "resultat.txt");

print OUT $dump;
close(OUT);
exit;

 <% end %>
</label>




   <h4><B>2) Solutions Perl + XSLT + XQuery permettant l'extraction de patrons morphosyntaxiques à partir des fichiers XML étiquetés par "TreeTagger" </B></h4>
   
    <div class="explication"><p>	Les données des fichiers taggés par TreeTagger se structurent en 3 colonnes:<br/><br/>
    					<ul>

    					<li>1. la catégorie morphosyntaxique du token</li><br/>
    					<li>2. son lemme</li><br/>
    					<li>3. le token </li><br/><br/>
				
    				</ul>

    Par exemple: <element><data type="type">NOM</data><data type="lemma">l’économiste</data><data type="string">l’économiste</data></element>
 <br/>

  
    </p></div><br/><br/>
  
   

     <%= image_tag 'cog_transparent_32px.png', :class => "icon" %><B>2.1) Programme Perl</B><br/><br/>
	 
	 
     <br/>Les deux programmes prennent comme argument: le fichier XML taggé par TreeTagger.<br/>

     Les programmes doivent retrouner des éléments lexicalisés correpsondant à la structure des fichiers des rubriques taggées.<br/><br/>

   <P>2.1.1) Pour le patron NOM_ADJ</P>
   
   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/BAO3_solu_treetagger_NOM_ADJ_utf.pl"} %>
   
 <% code("perl") do %>

#!/usr/bin/perl

open(FILE,"$ARGV[0]");
#--------------------------------------------
# le patron cherché ici est du type "NOM_ADJ"
#--------------------------------------------
my @lignes=<FILE>;
close(FILE);
while (my $ligne=shift(@lignes)) {
    chomp $ligne;
    my $sequence="";
    my $longueur=0;
    if ( $ligne =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
    my $forme=$1;
    $sequence.=$forme;
    $longueur=1;
    my $nextligne=$lignes[1]; # saut de ligne dans nos fichiers XML
      if ( $nextligne =~ /<element><data type=\"type\">ADJ<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
        my $forme=$1;
        $sequence.=" ".$forme;
        $longueur=2;
      }
    }
    if ($longueur == 2) {
      print $sequence,"\n";
    }
}
   

 <% end %>
</label>


 

    <P>2.1.2) Pour le patron NOM_PRP_NOM</P>
  
    <label>

  <%= partial "partials/code", :locals => { :code_file => "assets/ferial/BAO3_solu_treetagger_NOM_PREP_NOM_utf.pl"} %>
   
 <% code("perl") do %>

#!/usr/bin/perl

open(FILE,"$ARGV[0]");
#--------------------------------------------
# le patron cherché ici est du type "NOM_PRP_NOM";

#--------------------------------------------
my @lignes=<FILE>;
close(FILE);
while (my $ligne=shift(@lignes)) {
    chomp $ligne;
    my $sequence="";
    my $longueur=0;

    if ( $ligne =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
    my $forme=$1;
    $sequence.=$forme;
    $longueur=1;

    my $nextligne=$lignes[1]; # saut de ligne dans nos fichiers XML
      if ( $nextligne =~ /<element><data type=\"type\">PRP<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
        my $forme=$1;
        $sequence.=" ".$forme;
        $longueur=2;

        my $nextligne1=$lignes[3]; # saut de ligne dans nos fichiers XML
        if ( $nextligne1 =~ /<element><data type=\"type\">NOM<\/data><data type=\"lemma\">[^<]+<\/data><data type=\"string\">([^<]+)<\/data><\/element>/) {
          my $forme=$1;
          $sequence.=" ".$forme;
          $longueur=3;
        }
      }
    }
    if ($longueur == 3) {
    

    print $sequence,"\n";
     
    }
}

 <% end %>
 <label/>


 


   <%= image_tag 'xsl.png', :class => "icon" %><B>2.2) Feuilles de Style XSL </B>

 <P>2.2.1) Pour le patron NOM_ADJ</P>
 
   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/NOM-ADJ_utf.xsl"} %>

  <% code("xslt") do %>

<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="xs"
    version="2.0">
        <xsl:output method="text" encoding="utf-8"/>
        <xsl:template match="/">
        <xsl:apply-templates select="//element"/>
        </xsl:template>
        <xsl:template match="element">
            <xsl:choose>
                <xsl:when test="(./data[contains(text(),'NOM')]) and (following-sibling::element[1][./data[contains(text(),'ADJ')]])">
                    <xsl:value-of select="./data[3]"/>
                    <xsl:text> </xsl:text>
                </xsl:when>
                <xsl:when test="(./data[contains(text(),'ADJ')]) and (preceding-sibling::element[1][./data[contains(text(),'NOM')]])">
                    <xsl:value-of select="./data[3]"/>
                    <xsl:text>&#xA;</xsl:text>
                </xsl:when>
            </xsl:choose>
        </xsl:template>
</xsl:stylesheet>

 <% end %>
</label>

 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 
 
  <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>

 <P>2.2.2) Pour le patron NOM_PREP_NOM</P>
 
   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/NOM-PRP-NOM_utf.xsl"} %>

  <% code("xslt") do %>

  <?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="xs"
    version="1.0">
<xsl:output method="text" encoding="utf-8"/>
    <xsl:template match="/">
    <xsl:apply-templates select=".//article"/>
    </xsl:template>
    <xsl:template match="article">
        <xsl:for-each select="element">
            <xsl:if test="(./data[1][contains(text(),'NOM')])">
                <xsl:variable name="p1" select="./data[3]/text()"/>
                <xsl:if test="following-sibling::element[1][./data[1][contains(text(),'PRP')]]">
                    <xsl:variable name="p2" select="following-sibling::element[1]/data[3]/text()"/>
                    <xsl:if test="following-sibling::element[2][./data[1][contains(text(),'NOM')]]">
                        <xsl:variable name="p3" select="following-sibling::element[2]/data[3]/text()"/>
                        <xsl:value-of select="$p1"/>
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="$p2"/>
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="$p3"/>
                    <xsl:text>&#xA;</xsl:text>
                    </xsl:if>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
</xsl:stylesheet>

 <% end %>
</label>

 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 
 
  <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>


 <P>2.2.3) Pour le patron DET_ADJ_NOM</P>
 
   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/DET-ADJ-NOM_utf.xsl"} %>

  <% code("xslt") do %>

<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="xs"
    version="1.0">
    <xsl:output method="text" encoding="utf-8"/>
    <xsl:template match="/">
    <xsl:apply-templates select=".//article"/>
    </xsl:template>
    <xsl:template match="article">
        <xsl:for-each select="element">
            <xsl:if test="(./data[1][contains(text(),'PRP:det')])">
                <xsl:variable name="p1" select="./data[3]/text()"/>
                <xsl:if test="following-sibling::element[1][./data[1][contains(text(),'ADJ')]]">
                    <xsl:variable name="p2" select="following-sibling::element[1]/data[3]/text()"/>
                    <xsl:if test="following-sibling::element[2][./data[1][contains(text(),'NOM')]]">
                        <xsl:variable name="p3" select="following-sibling::element[2]/data[3]/text()"/>
                        <xsl:value-of select="$p1"/>
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="$p2"/>
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="$p3"/>
                        <xsl:text>&#xA;</xsl:text>
                    </xsl:if>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
</xsl:stylesheet>

 <% end %>
</label>

 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 
 
  <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>

  <%= image_tag 'xquery.png', :class => "icon" %><B>2.3) Requêtes XQuery</B> 

 <P>2.3.1) Pour le patron NOM_ADJ</P>
 
   <label>

 <%= partial "partials/code", :locals => { :code_file => "assets/ferial/DET-ADJ-NOM_utf.xsl"} %>
 

  <% code("xquery") do %>
<corpus> { for $art in doc("numéro_de_la_rubrique")//article 
for $elt in $art/element 
let $nextelt := $elt/following-sibling::element[1] 
let $nextelt2 := $nextelt/following-sibling::element[1] 
where $elt/data[1] = "NOM" and $nextelt/data[1] = "PRP" and $nextelt2/data[1] = "NOM" 
return <NOMPRPNOM>{$elt/data[2]/text(), " ", $nextelt/data[2]/text(), " ",$nextelt2/data[2]/text()}</NOMPRPNOM> 
} </corpus> 
<% end %>
</label>

<p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 
 
  <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>


  <P>2.3.2) Pour le patron NOM_PRP_NOM</P>
  
    <label>

  <%= partial "partials/code", :locals => { :code_file => "assets/ferial/DET-ADJ-NOM_utf.xsl"} %>
  

<% code("xquery") do %>
<corpus> { for $art in doc("numéro_de_la_rubrique")//article 
for $elt in $art/element 
let $nextelt := $elt/following-sibling::element[1] where $elt/data[1] = "NOM" and $nextelt/data[1] = "ADJ"
return <NOMADJ>{$elt/data[3]/text(), " ", $nextelt/data[3]/text()}</NOMADJ> }
</corpus>
<% end %>
</label>

 
 <div class="explication"><p><%= image_tag 'sheet_transparent_32px.png', :class => "icon" %>Vous trouverez dans ce tableau l'intégralité des résultats obtenus, au format TXT et HTML. Ils sont classés par motif, puis par étiqueteur afin de pouvoir comparer les résultats plus facilement.</p></div>

 <div class= "tableau"><table style="float:center">
   <tr>
     <th colspan="2">Motifs</th>
     <th>Rubrique 3476 (Cinéma)</th>
     <th>Rubrique 3232 (Idées)</th>
     <th>Rubrique 3260 (Livres)</th>
   </tr>
   <tr>
   <th rowspan="2">ADJ NOM</th>
   <td>Cordial</td>
   <td>TXT</td>
   <td>TXT</td>
   <td>TXT</td>
   </tr>
   <tr>
     <td>Treetagger</td>
     <td>TXT, HTML</td>
     <td>TXT, HTML</td>
     <td>TXT, HTML</td>
   </tr>
   <tr>
   <th rowspan="2">NOM ADJ</th>
   <td>Cordial</td>
   <td>TXT</td>
   <td>TXT</td>
   <td>TXT</td>
   </tr>
   <tr>
     <td>Treetagger</td>
     <td>TXT, HTML</td>
     <td>TXT, HTML</td>
     <td>TXT, HTML</td>
   </tr>
   <tr>
   <th rowspan="2">ADV VERBE ADV</th>
   <td>Cordial</td>
   <td>TXT</td>
   <td>TXT</td>
   <td>TXT</td>
   </tr>
   <tr>
     <td>Treetagger</td>
     <td>TXT, HTML</td>
     <td>TXT, HTML</td>
     <td>TXT, HTML</td>
   </tr>
 </table></div>
 
 
 
  <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 
 
 <%= partial "partials/h3", :locals => { :raccourci => "bao4", :titre => "Boîte à outils 4 : Création des graphes"} %>
 <%= partial "partials/onglets_bao_ferial" %>
 
  <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 
 
  <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 


 
 
 <%= partial "partials/h3", :locals => { :raccourci => "bao4", :titre => "Analyse"} %>
 <%= partial "partials/onglets_bao_ferial" %>
 
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 
 <%= partial "partials/h3", :locals => { :raccourci => "analyse", :titre => "Analyse"} %>
 <%= partial "partials/onglets_bao_ferial" %>
 
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 <%= partial "partials/h3", :locals => { :raccourci => "conclu", :titre => "Conclusion"} %>
 <%= partial "partials/onglets_bao_ferial" %>
 
 
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 <p>Bullshit</p>
 <p> Bullshit</p>
 <p>Bullshit</p>
 
 
 
 
 
 
 
 
 
